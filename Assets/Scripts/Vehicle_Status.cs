using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.SceneManagement;
using System;

public class Vehicle_Status : MonoBehaviour
{
    // Basic Vehicle Stats like health, speed, etc
    // Possible for future upgrades
    public float maxHealth = 100f;
    public float currentHealth { get; private set; }
    public float speed = 50f;
    public float damageResistance = 0f; 
    public float damage=2f;
    public int upgradePoints = 0;
    public TMP_Text health; //Health text I created in main scene
    [SerializeField] private Slider healthBar; //Health Bar slider I created in main scene

    public static Vehicle_Status vehicle_Status;


    //shield properties
    public float maxShieldPoints = 50f;
    public float currentShieldPoints;
    public GameObject shieldPrefab;
    public event DeathEvent OnDeath;
    public delegate void DeathEvent(Vehicle_Status player);
    private GameObject activeShield;
    private bool isBurning;
    private Coroutine burnCoroutine;
    
    // Audio variables
    [SerializeField] private AudioSource audioSource;
    [SerializeField] private AudioClip collisionSound;
    [SerializeField] private float minCollisionForce = 2f;  // Minimum velocity to make sound
    [SerializeField] private float maxCollisionForce = 20f; // Velocity for maximum volume
    public void Start()
    {
        currentHealth = maxHealth;
        Basic_Status_UI.basic_Status_UI.UpdateUI(currentHealth,maxHealth,(int)currentShieldPoints);

        //starts the audio source
        if (audioSource == null)
        {
            audioSource = gameObject.AddComponent<AudioSource>();
        }
    }

    public void Awake(){
        if(vehicle_Status!=null){
            Destroy(gameObject);
        }else{
            vehicle_Status=this;
        }
        DontDestroyOnLoad(this);
    }

    // Damage the vehicle, applying resistance modifier
    public void TakeDamage(float amount)
    {
        if(currentShieldPoints>0){
            currentShieldPoints -= amount;
            amount-=currentShieldPoints;
            currentShieldPoints = Mathf.Clamp(currentShieldPoints, 0, maxShieldPoints);
            Debug.Log($"Shield absorbed {amount} damage. Shield Points remaining: {currentShieldPoints}");

            if (currentShieldPoints <= 0 && activeShield != null)
            {
                Destroy(activeShield);  // Deactivate shield visual
                Debug.Log("Shield depleted!");
            }
        }
        //since the shield still up there, all damage have already being received, we just return, for time efficiency
        if(amount<0){
            Basic_Status_UI.basic_Status_UI.UpdateUI(currentHealth,maxHealth,(int)currentShieldPoints);
            return;
        } 
        //if shield break and still some damage left
        float damageAfterResistance = amount * (1 - damageResistance); //damage after resist
        currentHealth -= damageAfterResistance;
        currentHealth = Mathf.Clamp(currentHealth, 0, maxHealth);

        // Debug.Log($"Vehicle took {damageAfterResistance} damage. Health remaining: {currentHealth}");
        Basic_Status_UI.basic_Status_UI.UpdateUI(currentHealth,maxHealth,(int)currentShieldPoints);
        

        if (currentHealth <= 0) //destroy the vehicle if health is low enough
        {
            OnDeath?.Invoke(this);
            StopBurning();
            DestroyVehicle();
            GameManager.Instance.LoadDefeat();
        }
    }

    public void StartBurning(int damagePerSecond)
    {
        isBurning = true;
        if (burnCoroutine != null)
        {
            StopCoroutine(burnCoroutine);
        }
        burnCoroutine = StartCoroutine(Burn(damagePerSecond));
    }

    private IEnumerator Burn(int damagePerSecond)
    {
        float minTimeToDamage = 1f / damagePerSecond;
        WaitForSeconds wait = new WaitForSeconds(minTimeToDamage);
        int damagePerTick = Mathf.FloorToInt(minTimeToDamage) + 1;

        TakeDamage(damagePerSecond);
        while (isBurning)
        {
            yield return wait;
            TakeDamage(damagePerTick);
        }
    }

    public void StopBurning()
    {
        isBurning = false;
        if (burnCoroutine != null)
        {
            StopCoroutine(burnCoroutine);
        }
    }

    // Health regeneration feature
    public void RegenerateHealth(float regenAmount)
    {
        currentHealth += regenAmount;
        currentHealth = Mathf.Clamp(currentHealth, 0, maxHealth);
        Basic_Status_UI.basic_Status_UI.UpdateUI(currentHealth,maxHealth,(int)currentShieldPoints);
        Debug.Log($"Health regenerated by {regenAmount}. Current health: {currentHealth}");
    }

    // Destroy the vehicle if zero health
    public void DestroyVehicle()
    {
        // Implement destruction effects (explosions, disable controls, etc.)
        Debug.Log("Vehicle destroyed!");
        StartCoroutine(DestroyVehicleWithDelay());


    }


    private IEnumerator DestroyVehicleWithDelay()
    {
        PlayerCarDestruction destructionScript = GetComponent<PlayerCarDestruction>();
        if (destructionScript != null)
        {
            yield return StartCoroutine(destructionScript.DeconstructCar());
            yield return new WaitForSeconds(1f);
        }


        SceneManager.LoadScene("MainMenu");
    }
    private void ActivateShield()
    {
        if (shieldPrefab != null && currentShieldPoints > 0)
        {
            activeShield = Instantiate(shieldPrefab, transform.position, Quaternion.identity, transform);
            AdjustShieldSizeToVehicle();
        }
    }
    private void AdjustShieldSizeToVehicle()
    {
        // Calculate the bounds of the vehicle
        Bounds vehicleBounds = GetComponentInChildren<Renderer>().bounds;
        float maxDimension = Mathf.Max(vehicleBounds.size.x, vehicleBounds.size.y, vehicleBounds.size.z);

        // Scale the shield to be slightly larger than the vehicle
        float shieldScaleFactor = maxDimension * 1.2f; // Adjust as needed for desired buffer
        activeShield.transform.localScale = new Vector3(shieldScaleFactor, shieldScaleFactor, shieldScaleFactor);
    }

    public void Shielding()
    {
        currentShieldPoints = 50;
        //Debug.Log($"Shielding. Current shield points: {currentShieldPoints}");

        if (currentShieldPoints > 0 && activeShield == null)
        {
            ActivateShield();  // Reactivate shield if it regenerates from zero
        }
        Basic_Status_UI.basic_Status_UI.UpdateUI(currentHealth,maxHealth,(int)currentShieldPoints);
        Debug.Log("Shielding");
    }
    public void OnCollisionEnter(Collision collision){
        // Get the collision velocity magnitude
        float collisionForce = collision.relativeVelocity.magnitude;
        
        // Only play sound if collision force is above minimum
        if (collisionForce >= minCollisionForce)
        {
            // Calculate volume based on collision force
            float normalizedForce = (collisionForce - minCollisionForce) / (maxCollisionForce - minCollisionForce);
            float volume = Mathf.Clamp01(normalizedForce); // Clamp between 0 and 1
            
            // Call collision sound with calculated volume
            CollisionSound(volume);
            
            Debug.Log($"Collision Force: {collisionForce}, Volume: {volume}");
        }
    }
        // Add new collision sound method
    public void CollisionSound(float collisionIntensity)
    {
        if (audioSource != null && collisionSound != null)
        {
            float volume = Mathf.Clamp01(collisionIntensity);
            audioSource.PlayOneShot(collisionSound, volume);
        }
    }
}
